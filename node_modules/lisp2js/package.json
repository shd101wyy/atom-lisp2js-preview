{
  "name": "lisp2js",
  "version": "0.0.34",
  "description": "A simple lisp to javascript translater",
  "main": "lisp2js.js",
  "scripts": {
    "test": "lisp2js"
  },
  "bin": {
    "lisp": "./lisp2js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/shd101wyy/lisp2js.git"
  },
  "keywords": [
    "lisp",
    "Lisp",
    "LISP",
    "compiler",
    "interpreter",
    "eval"
  ],
  "author": {
    "name": "Yiyi Wang",
    "url": "shd101wyy"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/shd101wyy/lisp2js/issues"
  },
  "dependencies": {
    "js-beautify": "^1.5.4"
  },
  "homepage": "https://github.com/shd101wyy/lisp2js",
  "readme": "lisp2js beta\n=======\n#### By Yiyi Wang (shd101wyy)\n\n##### Simple Lisp that compiles to JavaScript ~~(targeting ECMAScript 6)~~\n##### ~~So ECMAScript 5 might not work.~~\n###### As es6 is not fully supported, the language will compile to es5.  \n---------------\n#### npm / github\n[npm](https://www.npmjs.com/package/lisp2js)  \n[github](https://github.com/shd101wyy/lisp2js)\n#### Installation\n```sh\n    npm -g install lisp2js  \n```\n#### How to run  \n```sh\n    lisp2js                               # repl\n    lisp2js   [file1.lisp]                # run file1.lisp\n    lisp2js   [file1.lisp]  [file2.js]    # compile [file1.lisp] to js file [file2.js]\n```\n----------------\n#### Use lisp2js in Browser\n```html\n<script src=\"lisp2js.js\"></script>\n<script>\n    var output = lisp.compile(\"(def x 12)\"); // compile/eval expression, then return compiled result.\n</script>\n```\n----------------\n### [Click Me to Try it Online](https://rawgit.com/shd101wyy/lisp2js/master/demo/translater.html)\n### [Online REPL](https://rawgit.com/shd101wyy/lisp2js/master/demo/repl.html)\n----------------\n#### all comma, tab, space will be ignored.\n----------------\n#### Examples\n<strong> Basics </strong>\n-     comment\n```lisp\n    ; semicolon is used as comment\n    ;; this is comment\n```\n\n-     define variable value\n```lisp\n    (def x 12)\n    (def ->this*name$invalid@in*js 13)   ;; a invalid js variable name, which will be replaced with another name.\n    (def ** Math.pow)\n```\n```javascript\n    var x = 12;\n    var _$45__$62_this_$42_name$invalid_$64_in_$42_js = 13;  // all invalid characters are replaced with its own charcode.\n    var _$42__$42_ = Math.pow;\n```\n\n- change variable value  \n```lisp\n    (= x 15)  \n```\n```javascript\n    x = 15;\n```\n\n- define function\n```lisp\n    (def add (a b)\n        (+ a b))\n```\n```javascript\n    var add = function(a, b){\n        return a + b;\n    }\n```\n\n- call function\n```lisp\n    (add 3 4)\n```\n```javascript\n    add(3, 4);\n```\n\n- define function with default parameters\n```lisp\n    (def add (:a 12 :b 3)\n        (+ a b))\n```\n```javascript\n    var add = function(a, b) {\n        a = (a === void 0 ? 12 : a);\n        b = (b === void 0 ? 3 : b);\n        return (a + b);\n    };\n```\n\n- define function with keyword parameters\n```lisp\n    (def add (x {:y 1 :z 2})\n        (+ x y z))\n    (add 0)        ;;  3\n    (add 1 :y 3)   ;;  6\n```\n```javascript\n    var add = function(x, __lisp_args__) {\n        var __lisp_args_v__;\n        __lisp_args__ = (__lisp_args__ === void 0 ? {} : __lisp_args__);\n        var y = ((__lisp_args_v__ = __lisp_args__.y) === void 0 ? 1 : __lisp_args_v__);\n        var z = ((__lisp_args_v__ = __lisp_args__.z) === void 0 ? 2 : __lisp_args_v__);\n        return (x + y + z);\n    };\n    add(0);\n    add(1, {\n        y: 3\n    });\n```\n\n- call function with named(keyword) parameters  \n```lisp\n    (def add ({:a 1 :b 2}) (+ a b))\n    (add)                  ;; => 3\n    (add :a 3 :b 4)        ;; => 7\n    (add :b 3)             ;; => 4\n```\n```javascript\n    var add = function(__lisp_args__) {\n        var __lisp_args_v__;\n        __lisp_args__ = (__lisp_args__ === void 0 ? {} : __lisp_args__);\n        var a = ((__lisp_args_v__ = __lisp_args__.a) === void 0 ? 1 : __lisp_args_v__);\n        var b = ((__lisp_args_v__ = __lisp_args__.b) === void 0 ? 2 : __lisp_args_v__);\n        return (a + b);\n    };\n    add();\n    add({\n        a: 3,\n        b: 4\n    });\n    add({\n        b: 3\n    });\n```\n\n- define function with rest parameters\n```lisp\n    (def add (a & b)   ;; b here is Array\n        (+ a b[0]))\n    (def add (a . b)   ;; b here is List\n        (+ a (car b)))\n```\n```javascript\n    var add = function(a) {\n        for (var b = [], $__0 = 1; $__0 < arguments.length; $__0++) b[$__0 - 1] = arguments[$__0];\n        return (a + b[0]);\n    };\n    var add = function(a) {\n        for (var b = [], $__0 = 1; $__0 < arguments.length; $__0++) b[$__0 - 1] = arguments[$__0];\n        b = list.apply(null, b);\n        return (a + car(b));\n    };\n```\n\n- anonymous function\n```lisp\n    (fn (a :b 13 & c)\n        (+ a b c[0]))\n```\n```javascript\n    function (a, b){\n        for (var c = [], $__0 = 2; $__0 < arguments.length; $__0++) c[$__0 - 2] = arguments[$__0];\n        b = (b === void 0 ? 13 : b);\n        return (a + b + c[0]);\n    };\n```\n\n- do. run a series of exps.\n```lisp\n    (do  (+ 1 2)\n         (- 3 4)\n         (* 5 6))\n\n    (fn ()\n        (do (+ 1 2)\n            (- 3 4)\n            (* 5 6)))\n    (if 1\n        (do (def x 1) (def y 2))\n        (do (def x 2) (def y 1)))\n```\n```javascript\n    (1 + 2);\n    (3 - 4);\n    (5 * 6);;\n\n    function() {\n        (1 + 2);\n        (3 - 4);\n        return (5 * 6);;\n    };\n    if (1) {\n        var x = 1;\n        var y = 2;\n    } else {\n        var x = 2;\n        var y = 1;\n    };\n```\n\n- if\n```lisp\n    (if 1 2 3)\n    (def x (if 1 2 3))\n```\n```javascript\n    if (1) {\n        2\n    } else {\n        3\n    };\n    var x = (1 ? 2 : 3);\n```\n\n- cond\n```lisp\n    (cond test1 (do stm1 stm2)\n          test2 (do stm3 stm4)\n          test3 stm5\n          else stm6)\n```\n```javascript\n    if (test1) {\n      stm1;\n      stm2;\n    } else if (test2) {\n      stm3;\n      stm4;\n    } else if (test3) {\n      stm5;\n    } else {\n      stm6;\n    };\n```\n\n- case\n```lisp\n    (def test (x)\n        (case x\n            \"apple\" \"This is apple\"\n            \"orange\" \"This is orange\"\n            else \"This is nothing\"))\n```\n```javascript\n    var test = function(x) {\n        switch (x) {\n            case \"apple\":\n                return \"This is apple\";\n            case \"orange\":\n                return \"This is orange\";\n            default:\n                return \"This is nothing\";\n        };\n    };\n```\n\n- let (es5)  // I might change this to es6 <strong>let</strong> in the future\n```lisp\n    (let x 1\n        y 2\n        x (+ x y)\n        z 4\n        (+ x y z))\n    (+ (let x 1 y 2 (- x y))\n        3)\n    (def test ()\n        (let x 1 y 2 (+ x y)))\n```\n```javascript\n    ((function() {\n        var x = 1;\n        var y = 2;\n        x = (x + y);\n        var z = 4;\n        return (x + y + z)\n    })());\n    (((function() {\n        var x = 1;\n        var y = 2;\n        return (x - y)\n    })()) + 3);\n    var test = function() {\n        return ((function() {\n            var x = 1;\n            var y = 2;\n            return (x + y)\n        })());\n    };\n```\n\n- throw\n```lisp\n    (throw \"Too Big\")\n```\n```javascript\n    throw \"Too Big\";\n```\n\n- yield\n```lisp\n    (def test ()\n        (yield 1)\n        (yield 2))\n    (def x (test))\n    (x.next)   ;; 1\n    (x.next)   ;; 2\n    (x.next)   ;; stop\n```\n```javascript\n    var test = function() {\n        yield 1;\n        yield 2;\n        return;\n    };\n    var x = test();\n    x.next();\n    x.next();\n    x.next();\n```\n\n- try/catch/finally\n```lisp\n    (try (console.log \"This is try\")\n    catch e (console.log \"This is catch\")\n    finally (console.log \"This is finally\"))\n```\n```javascript\n    try {\n      console.log(\"This is try\");\n    } catch (e) {\n      console.log(\"This is catch\");\n    } finally {\n      console.log(\"This is finally\");\n    };\n```\n- some operators\n```lisp\n    (== 1 1)\n    (+ 1 2 3)\n    (- 1 2 3)\n    (* 1 2 3)\n    (/ 1 2 3)\n    (* (+ 1 2) (- 3 4))\n    (> 1 2 3 4)\n    (<= 1 2 3 4)\n    (&& true false)\n    (|| 1 2)\n    (| 1 0x12)\n    (and true false)\n    (or true false)\n    (not true)\n```\n```javascript\n    (1 === 1);\n    (1 + 2 + 3);\n    (1 - 2 - 3);\n    (1 * 2 * 3);\n    (1 / 2 / 3);\n    ((1 + 2) * (3 - 4));\n    (1 > 2 && 2 > 3 && 3 > 4);\n    (1 <= 2 && 2 <= 3 && 3 <= 4);\n    (true && false);\n    (1 || 2);\n    (1 | 0x12);\n    (true && false);\n    (true || false);\n    (!true);\n```\n\n- get  \n```lisp\n    (get \"abcd\" 'length)\n    (get console .log)\n```\n```javascript\n    \"abcd\"[\"length\"];\n    console.log;\n```\n\n- ->\n```lisp\n    (-> console (.log \"Hello World\"))\n    (-> $ (.post \"test.php\")\n          (.done (fn () \"done\"))\n          (.fail (fn () \"fail\")))\n    (-> \"i am cool\"\n        .length)\n```\n```javascript\n    console.log(\"Hello World\");\n    $.post(\"test.php\").done(function() {\n        return \"done\";\n    }).fail(function() {\n        return \"fail\";\n    });\n    \"i am cool\".length;\n```\n\n- class (this might be buggy, I will implement class in es6 in the future)\n```lisp\n    (class Animal\n        :constructor (fn (age)                ;; define constructor\n                        (= this.age age))\n        :showAge (fn ()                       ;; define method\n                    (console.log \"Called from Animal\")\n                    (console.log this.age)))\n    (class Dog extends Animal\n        :constructor (fn (age)                ;; define constructor\n                        (super age))          ;; call superclass constructor\n        :showAge (fn ()                       ;; define method\n                    (console.log \"Called from Dog\")\n                    (super.showAge))          ;; call superclass method\n        :bark (fn ()                          ;; define method\n                (console.log \"Bark!\")))\n\n    (def dog (new Dog 5))\n    (dog.showAge)  ;;  Called from Dog\n                   ;;  Called from Animal\n                   ;;  5\n\n    (dog.bark)     ;;  Bark!\n```\n\n- loop\n```lisp\n    ;; calculate factorial 10\n    (loop i 10\n          acc 1\n        (if (== i 0)\n            acc\n            (recur (- i 1)\n                   (* i acc))))\n```\n```javascript\n    (function __lisp__recur__$0(i, acc) {\n        if ((i === 0)) {\n            return acc\n        } else {\n            return __lisp__recur__$0((i - 1), (i * acc))\n        };\n    })(10, 1);\n```\n\n- new\n```lisp\n    (def x (new Array 1 2 3 4))\n```\n```javascript  \n    var x = (new Array(1, 2, 3, 4));\n```\n- in  \n```lisp\n    (in 'a {'a 12})\n```\n```javascript  \n    (\"a\" in {\"a\": 12});\n```  \n\n- instanceof\n```lisp\n    (instanceof [1 2 3] Array)\n```\n```javascript\n    ([1, 2, 3] instanceof Array)\n```\n-----------------------------------------\n-  <strong> List functions </strong>\n     * To enable <strong>List</strong> datatype, include lisp.js from https://github.com/shd101wyy/List_for_FP\n     *  after you compile your .lisp file to javascript file.\n     *  This file will give you 4 functions: car, cdr, cons, list.  \n     *                      and 1 datatype: $List  \n     *  See the link above for more information.\n- define a list.\n```lisp\n    (def x '(1 2 3))\n```\n```javascript\n    var x = cons(1, cons(2, cons(3, null)));\n```\n\n- quasiquote\n```lisp\n    (def x 12)\n    `(~x x)     ;; => (12 x)\n```\n```javascript\n    var x = 12;\n    cons(x, cons(\"x\", null));\n```\n\n- car, cdr, cons, list\n```lisp\n    (def a 1)\n    (def b 2)\n    (def c (cons a (cons b '())))   ;; => (1 2)\n    (car c)                         ;; => 1\n    (cdr c)                         ;; => (2)\n    (def l (list a b))           ;; => (1 2)\n```\n```javascript\n    var a = 1;\n    var b = 2;\n    var c = cons(a, cons(b, null));\n    car(c);\n    cdr(c);\n    var l = list(a, b);\n```\n---------------------------------------\n- <strong>Use JavaScript Object/Array</strong>\n\n- define Array\n```lisp\n    (def x [1 2 3])\n```\n```javascript\n    var x = [1, 2, 3];\n```\n\n- define Object\n```lisp\n    (def x {:a 12 b 13 \"c\" 14})\n```\n```javascript\n    // es6\n    var x = {a: 12, [b]: 13, \"c\": 14};\n```\n\n- es6 define value\n```lisp\n    (def [x y z] [1 2 3])\n    (def {:m :n} {:m 12 :n 20})\n```\n```javascript\n    // es6\n    var [x, y, z] = [1, 2, 3];\n    var {\n        m, n\n    } = {\n        m: 12,\n        n: 20\n    };\n```\n\n- change value  \n```lisp\n    (def x [1 2 3])\n    (= x[0] 12)\n    (def y {:a 12 :b 13 :c (fn (a b) (+ a b))})\n    (= y.a 13)\n    (= y[\"a\"] 13)\n```\n```javascript\n    var x = [1, 2, 3];\n    x[0] = 12;\n    var y = {\n        a: 12,\n        b: 13,\n        c: function(a, b) {\n            return (a + b);\n        }\n    };\n    y.a = 13;\n    y[\"a\"] = 13;\n```\n\n- get value\n```lisp\n    (def y {:a 12 :b 13 :c (fn (a b) (+ a b))})\n    (y.add y.a y.b)\n```\n```javascript\n    var y = {\n        a: 12,\n        b: 13,\n        c: function(a, b) {\n            return (a + b);\n        }\n    };\n    y.add(y.a, y.b);\n```\n---------------------------------------\n#### recur\n##### similar to recur in clojure\n- recur\n```lisp\n    (def test (n)\n      (cond (== n 0) 0\n            1 (recur (- n 2))                ;; recur here means test\n            else (recur (- n 1))))\n\n    ;; anonymous function recur\n    ((fn (n acc)\n      (if (== n 0)\n        acc\n        (recur (- n 1) (* n acc)))) 10 1)  ;; recur <=> that anonymous function\n```\n```javascript\n    var test = function(n) {\n      if ((n === 0)) {\n        return 0;\n      } else if (1) {\n        return test((n - 2));\n      } else {\n        return test((n - 1));\n      };\n    };\n    (function __lisp__recur__$0(n, acc) {\n      if ((n === 0)) {\n        return acc;\n      } else {\n        return __lisp__recur__$0((n - 1), (n * acc));\n      };\n    })(10, 1)\n```\n---------------------------------------\n#### Macro\n- define a macro (unhygienic right now)\n```lisp\n    (defmacro square (x) `(* ~x ~x))\n    (square 12)\n    (defmacro square-with-different-params\n        (x) `(* ~x ~x)\n        (x y) `(+ (* ~x ~x) (* ~y ~y)))\n    (square-with-different-params 12)\n    (square-with-different-params 15 16)\n```\n```javascript\n    (12 * 12);\n    (12 * 12);\n    ((15 * 15) + (16 * 16));\n```\n\n- macro-expand: expand a macro form\n```lisp\n    (defmacro square (x) `(* ~x ~x))\n    ;; the macro-expand function will expand the macro until it no longer represents a macro form.\n    (macro-expand '(square 12))  ; => '(* 12 12)\n\n    (defmacro test (x) `(test (+ 1 ~x)))\n    ;; macro-expand can also expand macro forms for n times.\n    (macro-expand '(test 1) 2)   ; => '(test (+ 1 (+ 1 1)))   this will expand macro twice.\n    (macro-expand '(test 1) 3)   ; => '(test (+ 1 (+ 1 (+ 1 1))))   this will expand macro for 3 times.\n```\n\n###### However, the macro implementation still has errors.\n---------------------------------------\n#### Change Log\n- <strong> 2015/3/15 </strong>\n- <strong> Version 0.0.33 </strong>\n    * fix one macro bug\n    * add <strong> => </strong>\n    * eg:\n    ```lisp\n        (=> (x y) (+ x y))   ;; es6 (x, y) => {return x + y};\n    ```\n- <strong> Version 0.0.31 ~ 0.0.32 </strong>\n- <strong> 2015/3/8 </strong>\n    * change code generation for <strong> class </strong> statement.\n    * add <strong> macro-expand </strong> function.\n    * eg:\n    ```lisp\n        (defmacro square (x) `(* ~x ~x))\n        ;; the macro-expand function will expand the macro until it no longer represents a macro form.\n        (macro-expand '(square 12))  ; => '(* 12 12)\n\n        (defmacro test (x) `(test (+ 1 ~x)))\n        ;; macro-expand can also expand macro forms for n times.\n        (macro-expand '(test 1) 2)   ; => '(test (+ 1 (+ 1 1)))   this will expand macro twice.\n        (macro-expand '(test 1) 3)   ; => '(test (+ 1 (+ 1 (+ 1 1))))   this will expand macro for 3 times.\n    ```\n- <strong> 2015/3/4 </strong>\n    * fix one macro bug.\n- <strong> Version 0.0.30 </strong>\n    * add <strong>class</strong> support (this might be buggy though)\n    * eg:\n    ```lisp\n        (class Animal\n            :constructor (fn (age)                ;; define constructor\n                            (= this.age age))\n            :showAge (fn ()\n                        (console.log \"Called from Animal\")\n                        (console.log this.age)))\n        (class Dog extends Animal\n            :constructor (fn (age)                ;; define constructor\n                            (super age))          ;; call superclass constructor\n            :showAge (fn ()\n                        (console.log \"Called from Dog\")\n                        (super.showAge))          ;; call superclass method\n            :bark (fn ()\n                    (console.log \"Bark!\")))\n\n        (def dog (new Dog 5))\n        (dog.showAge)  ;;  Called from Dog\n                       ;;  Called from Animal\n                       ;;  5\n\n        (dog.bark)     ;;  Bark!\n    ```\n- <strong> Version 0.0.28 </strong>\n- <strong> 2015/3/1 </strong>\n    * add <strong>case</strong> statement.  \n    * eg:  \n    ```lisp\n        (def test (x)\n            (case x\n                \"apple\" \"This is apple\"\n                \"orange\" \"This is orange\"\n                else \"This is nothing\"))\n        (test \"pear\")    ;; => This is nothing\n        (test \"apple\")   ;; => This is apple\n        (test \"orange\")  ;; => This is orange\n    ```\n    * fix one <strong>if</strong> and <strong>cond</strong> bug.\n- <strong> 2015/2/25 </strong>\n    * fix demo link error.\n- <strong> 2015/2/24 </strong>\n    * add <strong>loop</strong> macro\n    * eg:\n    ```lisp\n        ;; calculate factorial 10\n        (loop i 10\n              acc 1\n            (if (== i 0)\n                acc\n                (recur (- i 1)\n                       (* i acc))))\n    ```\n- <strong> 2015/2/23 </strong>\n    * add REPL demo\n    * fix <= >= < > == != comparison operator bug, they now support multiple arguments.\n    * eg:\n    ```lisp\n        (== 1 1 1)\n        (<= 1 2 3 4 5 2)\n    ```\n- <strong> Version 0.0.24 </strong>\n- <strong> 2015/2/22 </strong>\n    * add <strong> -> </strong> macro\n    * eg:\n    ```lisp\n        (-> console (.log \"Hello World\"))\n        (-> $ (.post \"test.php\")\n              (.done (fn () \"done\"))\n              (.fail (fn () \"fail\")))\n        (-> \"i am cool\"\n            .length)\n    ```\n    ```javascript\n        console.log(\"Hello World\");\n        $.post(\"test.php\").done(function() {\n            return \"done\";\n        }).fail(function() {\n            return \"fail\";\n        });\n        \"i am cool\".length;\n    ```\n- <strong> Version 0.0.20 - 0.0.22 </strong>\n- <strong> 2015/2/17 </strong>\n    * <strong> Happy New Year []~(￣▽￣)~* </strong>\n    * Add <strong> and, or, not </strong> macros that behave the same as <strong> &&  ||  !</strong>\n    * Change <strong>default parameters</strong> and <strong>keyword parameters</strong>.\n    * For example:\n    * <strong> Default Parameters </strong>\n    ```lisp\n        (def add (:a 1 :b 2)\n            (+ a b))\n        (add)     ;; => 3\n        (add 2)   ;; => 4\n        (add 3 4) ;; => 7\n    ```\n    * <strong> Keyword Parameters </strong>\n    *\n    ```lisp\n        (def add ({:x 1 :y 2})\n            (+ x y))\n        (add)            ;; => 3\n        (add :x 3)       ;; => 5\n        (add :y 6)       ;; => 7\n        (add :x 4 :y 5)  ;; => 9\n        (add :y 1 :x 5)  ;; => 6\n    ```\n- <strong> Version 0.0.18 </strong>\n- <strong> 2015/2/16 </strong>\n    * Add <strong>yield</strong> and <strong> throw </strong> support.\n- <strong> 2015/2/9 </strong>\n    * Improve compatibility with es5\n- <strong> 2015/2/7 </strong>\n    * Change the way of defining the default parameters and calling function with named parameters\n- <strong> 2015/1/31 </strong>\n    * Fix one macro bug.  \n- <strong> 2015/1/26 </strong>\n    * Change <strong> do </strong> function.  \n      (do ...) will be wrapped as function when it is argument or assignment value.\n- <strong> Version 0.0.13 </strong>\n    * add <strong> in </strong> support.\n    ```lisp\n    (in 'a {'a 12})\n    ```\n    ```javascript\n    (\"a\" in {\"a\": 12});\n    ```\n- <strong> Version 0.0.12 </strong>\n    * fix one macro bug.\n- <strong> 2015/1/23 </strong>\n    * change . & for rest parameters  \n    * . => list\n    * & => array  \n    ```lisp\n    (def add (a & b)   ;; b here is Array\n        (+ a b[0]))\n    (def add (a . b)   ;; b here is List\n        (+ a (car b)))\n    ```\n    ```javascript\n    // es6\n    var add = function(a, ...b){\n        return a + b[0];\n    }\n    var add = function(a, ...b) {\n        b = list.apply(null, b);\n        return (a + car(b));\n    };\n    ```\n- <strong>2015/1/19 </strong>\n    * add <strong> get </strong> fn  \n    * fix \"abc\".length like exp bug.  \n- <strong>2015/1/14 </strong>\n    * add <strong> cond </strong>\n    * add <strong> recur </strong> support\n    * add <strong> try/catch/finally </strong> support\n    * change <strong>if</strong> statement  \n    Went snowboarding and fell down too many times. I twisted my wrist unfortunately. (T_T)  \n\n- <strong>2015/1/7 </strong>\n    * add support for fn with name .\n```lisp\n    (fn add (x) (+ x y))\n```\n```javascript\n    function add(x) {\n        return (x + y);\n    };\n```\n    * fix one macro bug\n- <strong>2015/1/5 </strong>\n    * add support for <strong> const </strong>\n    * change <strong> let </strong>. see doc above.\n    * fix several bugs.\n- <strong>2015/1/5 First Release</strong>\n    * There are still lots of bugs.  \n    * ...\n---------------------------------------\nMIT License ;)\n",
  "readmeFilename": "README.md",
  "gitHead": "d5ad0e04829d69550158af523093d982f1424812",
  "_id": "lisp2js@0.0.34",
  "_shasum": "c9059210f3438ccc95a44ad335dd36ea825285a5",
  "_from": "lisp2js@0.0.34"
}
